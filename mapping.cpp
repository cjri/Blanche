//Program to calculate predicted sigma values for loci in a model system, where data is generated by a sampling process
//This code uses a deterministic method to run the underlying population distribution, and samples it at low frequency

#include <iostream>
#include <sstream>
#include <vector>
#include <list>
using namespace std;

#include "mapping.h"
#include "io.h"
#include "utilities.h"

int main(int argc, const char **argv){

    //Initialise random number generator
    run_params p;
    GetParameters(p,argc,argv);
    p.seed=(int) time(NULL);
    gsl_rng_env_setup();
    gsl_rng *rgen = gsl_rng_alloc (gsl_rng_taus);
    gsl_rng_set (rgen, p.seed);

    vector<string> seqs;
    //Read in sequence alignment
    ReadFastaAli (p,seqs);
    
    //NB need to account for errors and ambiguities in sequencing.  Can do this here later.
    
    //Find consensus sequence
    string all_consensus;
    FindConsensus(all_consensus,seqs);
    vector<sparseseq> variants;
    FindVariants (variants,all_consensus,seqs);

    if (p.fix==1) {
        FindAmbiguousVariants (variants,all_consensus,seqs);
    }
    
    if (p.verb==1) {
        for (int i=0;i<variants.size();i++) {
            cout << "i= " << i << "\n";
            for (int j=0;j<variants[i].locus.size();j++) {
                cout << variants[i].locus[j] << " " << variants[i].allele[j] << "\n";
            }
        }
    }

    
    //Find ambiguous nucleotides and convert to N if they are unresolvable
    FixVariants(seqs,variants);

    if (p.verb==1) {
        cout << "New variants\n";
        for (int i=0;i<variants.size();i++) {
            cout << "i= " << i << "\n";
            for (int j=0;j<variants[i].locus.size();j++) {
                cout << variants[i].locus[j] << " " << variants[i].allele[j] << "\n";
            }
        }
    }
    
    //Output variant positions
    vector<int> positions;
    for (int i=0;i<variants.size();i++) {
        for (int j=0;j<variants[i].locus.size();j++) {
            positions.push_back(variants[i].locus[j]);
        }
    }
    sort(positions.begin(),positions.end());
    positions.erase(unique(positions.begin(),positions.end()),positions.end());
    if (p.verb==1) {
        OutputPositions(positions);
    }
    vector<int> npos;
    FindNPos(npos,variants);

    //Find consensus at these positions
    vector<char> count_consensus;
    for (int i=0;i<npos.size();i++) {
        count_consensus.push_back(all_consensus[npos[i]]);
    }
    
    //Find distances for the N: From the consensus.  count[i] = Distance from the consensus to attribute to an N.
    vector<double> count;
    MakeCounts(count,npos,variants);
            
    //Find distance matrix between sequences
    vector< vector<double> > seqdists;
    FindPairwiseDistances (p,npos,count,count_consensus,seqdists,variants,seqs);
    
    if (p.verb==1) {
        OutputSeqDistances (seqdists);
    }
    
    //Find sets of identical sequences
    vector< vector<int> > subsets;
    GenerateSubsets(seqs,seqdists,subsets);
    
    //Initialise vector of points
    vector< vector<double> > points;
    InitialisePoints(p,subsets,points);
    
    vector<int> pset;  //Sequence i is in subset pset[i]
    GeneratePset (seqs,subsets,pset);
        
    //Initialise points distance matrix
    vector< vector<double> > pdists;
    InitilisePDistMatrix (points,pdists);
        
    //Iteration of points
    int first=1;
    double dist=1e6;
    double dist_best=1e6;
    double dm=0.01;
    vector< vector<double> > points_best=points;
    for (int it=0;it<1000000;it++) {
        if (first==0) {
            if (dist<dist_best) {
                points_best=points;
                dist_best=dist;
                //cout << "Better distance " << dist << "\n";
            } else {
                points=points_best;
            }
        }
        first=0;
        
        //Random change to points
        for (int i=0;i<points.size();i++) {
            for (int j=0;j<p.dim;j++) {
                points[i][j]=points[i][j]+(gsl_rng_uniform(rgen)*dm)-(dm/2);
            }
        }
        //Calculate distances between points compared to sequence distances
        CalculatePointDistanceMatrix (points,pdists);
        //Calculate distance comparison
        dist=GetDistanceComparison(seqdists,pset,pdists);
        //cout << "Distance " << dist << "\n";
        
    }
    
    OutputPoints(seqs,pset,points);
    OutputDistance(dist_best);
    OutputSubsets(subsets);
        
    return 0;
}
	
	
